;
; File generated by cc65 v 2.16 - Git 83890e5
;
	.fopt		compiler,"cc65 v 2.16 - Git 83890e5"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_NMI_flag
	.export		_Frame_Count
	.export		_index
	.export		_index4
	.export		_X1
	.export		_Y1
	.export		_state
	.export		_state4
	.export		_joypad1
	.export		_joypad1old
	.export		_joypad1test
	.export		_joypad2
	.export		_joypad2old
	.export		_joypad2test
	.export		_Horiz_scroll
	.export		_Horiz_scroll_Old
	.export		_Scroll_Adjusted_X
	.export		_Nametable
	.export		_NametableB
	.export		_walk_count
	.export		_X_speed
	.export		_Y_speed
	.export		_direction
	.export		_collision_Index
	.export		_high_byte
	.export		_collision
	.export		_temp
	.export		_Sprites
	.export		_map1
	.export		_map2
	.export		_N1
	.export		_N2
	.export		_C1
	.export		_C2
	.export		_Platform
	.export		_Palette
	.export		_Walk_Moves
	.export		_MetaSprite_Y
	.export		_MetaSprite_X
	.export		_MetaSprite_Tile_R
	.export		_MetaSprite_Tile_L
	.export		_MetaSprite_Attrib_R
	.export		_MetaSprite_Attrib_L
	.export		_AllOff
	.export		_AllOn
	.export		_ResetScroll
	.export		_LoadPalette
	.export		_UpdateSprites
	.export		_CollisionDown
	.export		_MoveLogic
	.export		_ComputeAnimation
	.export		_DrawBackground
	.import		_memcpy
	.import		_Wait_Vblank
	.import		_UnRLE
	.import		_Get_Input
	.export		_main

.segment	"RODATA"

_N1:
	.byte	$01
	.byte	$00
	.byte	$01
	.byte	$FE
	.byte	$00
	.byte	$01
	.byte	$D8
	.byte	$14
	.byte	$01
	.byte	$07
	.byte	$00
	.byte	$01
	.byte	$17
	.byte	$14
	.byte	$01
	.byte	$07
	.byte	$00
	.byte	$01
	.byte	$09
	.byte	$14
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$1B
	.byte	$14
	.byte	$01
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$67
	.byte	$14
	.byte	$01
	.byte	$09
	.byte	$00
	.byte	$01
	.byte	$15
	.byte	$14
	.byte	$01
	.byte	$09
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$05
	.byte	$06
	.byte	$01
	.byte	$09
	.byte	$07
	.byte	$00
	.byte	$01
	.byte	$13
	.byte	$15
	.byte	$16
	.byte	$01
	.byte	$09
	.byte	$17
	.byte	$00
	.byte	$01
	.byte	$13
	.byte	$15
	.byte	$16
	.byte	$01
	.byte	$09
	.byte	$17
	.byte	$00
	.byte	$01
	.byte	$13
	.byte	$18
	.byte	$19
	.byte	$01
	.byte	$09
	.byte	$1A
	.byte	$00
	.byte	$01
	.byte	$0D
	.byte	$02
	.byte	$01
	.byte	$7F
	.byte	$00
	.byte	$01
	.byte	$28
	.byte	$40
	.byte	$50
	.byte	$50
	.byte	$10
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$F0
	.byte	$F4
	.byte	$F5
	.byte	$F5
	.byte	$F1
	.byte	$F0
	.byte	$01
	.byte	$02
	.byte	$0F
	.byte	$01
	.byte	$07
	.byte	$01
	.byte	$00
_N2:
	.byte	$01
	.byte	$00
	.byte	$01
	.byte	$FE
	.byte	$00
	.byte	$01
	.byte	$90
	.byte	$14
	.byte	$01
	.byte	$09
	.byte	$00
	.byte	$01
	.byte	$15
	.byte	$14
	.byte	$01
	.byte	$09
	.byte	$00
	.byte	$01
	.byte	$8D
	.byte	$05
	.byte	$06
	.byte	$01
	.byte	$09
	.byte	$07
	.byte	$00
	.byte	$01
	.byte	$13
	.byte	$15
	.byte	$16
	.byte	$01
	.byte	$09
	.byte	$17
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$14
	.byte	$14
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$15
	.byte	$16
	.byte	$01
	.byte	$09
	.byte	$17
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$14
	.byte	$14
	.byte	$00
	.byte	$01
	.byte	$05
	.byte	$15
	.byte	$16
	.byte	$01
	.byte	$09
	.byte	$17
	.byte	$00
	.byte	$01
	.byte	$13
	.byte	$15
	.byte	$16
	.byte	$01
	.byte	$08
	.byte	$14
	.byte	$01
	.byte	$05
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$15
	.byte	$16
	.byte	$01
	.byte	$08
	.byte	$14
	.byte	$01
	.byte	$05
	.byte	$00
	.byte	$01
	.byte	$0F
	.byte	$15
	.byte	$16
	.byte	$01
	.byte	$09
	.byte	$0A
	.byte	$00
	.byte	$01
	.byte	$13
	.byte	$18
	.byte	$19
	.byte	$01
	.byte	$09
	.byte	$1A
	.byte	$00
	.byte	$01
	.byte	$0B
	.byte	$02
	.byte	$01
	.byte	$80
	.byte	$00
	.byte	$01
	.byte	$20
	.byte	$50
	.byte	$01
	.byte	$02
	.byte	$00
	.byte	$01
	.byte	$04
	.byte	$55
	.byte	$55
	.byte	$15
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$F0
	.byte	$F0
	.byte	$F5
	.byte	$01
	.byte	$02
	.byte	$F0
	.byte	$01
	.byte	$02
	.byte	$0F
	.byte	$01
	.byte	$07
	.byte	$01
	.byte	$00
_C1:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$03
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$09
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0B
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
_C2:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$03
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$06
	.byte	$07
	.byte	$07
	.byte	$07
	.byte	$07
	.byte	$08
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$06
	.byte	$07
	.byte	$07
	.byte	$07
	.byte	$07
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$09
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0B
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
_Platform:
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_Palette:
	.byte	$22
	.byte	$16
	.byte	$36
	.byte	$0F
	.byte	$00
	.byte	$08
	.byte	$18
	.byte	$39
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$20
	.byte	$00
	.byte	$0A
	.byte	$1A
	.byte	$2A
	.byte	$22
	.byte	$37
	.byte	$16
	.byte	$0F
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$15
_Walk_Moves:
	.byte	$00
	.byte	$01
	.byte	$00
	.byte	$02
_MetaSprite_Y:
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$08
_MetaSprite_X:
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$08
_MetaSprite_Tile_R:
	.byte	$00
	.byte	$01
	.byte	$10
	.byte	$11
	.byte	$02
	.byte	$03
	.byte	$12
	.byte	$13
	.byte	$04
	.byte	$05
	.byte	$14
	.byte	$15
	.byte	$06
	.byte	$07
	.byte	$16
	.byte	$17
_MetaSprite_Tile_L:
	.byte	$01
	.byte	$00
	.byte	$11
	.byte	$10
	.byte	$03
	.byte	$02
	.byte	$13
	.byte	$12
	.byte	$05
	.byte	$04
	.byte	$15
	.byte	$14
	.byte	$07
	.byte	$06
	.byte	$17
	.byte	$16
_MetaSprite_Attrib_R:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_MetaSprite_Attrib_L:
	.byte	$40
	.byte	$40
	.byte	$40
	.byte	$40

.segment	"BSS"

.segment	"ZEROPAGE"
_NMI_flag:
	.res	1,$00
_Frame_Count:
	.res	1,$00
_index:
	.res	1,$00
_index4:
	.res	1,$00
_X1:
	.res	1,$00
_Y1:
	.res	1,$00
_state:
	.res	1,$00
_state4:
	.res	1,$00
_joypad1:
	.res	1,$00
_joypad1old:
	.res	1,$00
_joypad1test:
	.res	1,$00
_joypad2:
	.res	1,$00
_joypad2old:
	.res	1,$00
_joypad2test:
	.res	1,$00
_Horiz_scroll:
	.res	1,$00
_Horiz_scroll_Old:
	.res	1,$00
_Scroll_Adjusted_X:
	.res	2,$00
_Nametable:
	.res	1,$00
_NametableB:
	.res	1,$00
_walk_count:
	.res	1,$00
_X_speed:
	.res	1,$00
_Y_speed:
	.res	1,$00
_direction:
	.res	1,$00
_collision_Index:
	.res	1,$00
_high_byte:
	.res	1,$00
_collision:
	.res	1,$00
_temp:
	.res	1,$00
.segment	"OAM"
_Sprites:
	.res	256,$00
.segment	"MAP"
_map1:
	.res	256,$00
_map2:
	.res	256,$00

; ---------------------------------------------------------------
; void __near__ AllOff (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_AllOff: near

.segment	"CODE"

;
; PPU_CTRL = 0;
;
	lda     #$00
	sta     $2000
;
; PPU_MASK = 0;
;
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ AllOn (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_AllOn: near

.segment	"CODE"

;
; PPU_CTRL = 0x90; // screen is on, NMI on
;
	lda     #$90
	sta     $2000
;
; PPU_MASK = 0x1e;
;
	lda     #$1E
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ResetScroll (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ResetScroll: near

.segment	"CODE"

;
; PPU_ADDRESS = 0;
;
	lda     #$00
	sta     $2006
;
; PPU_ADDRESS = 0;
;
	sta     $2006
;
; SCROLL = 0;
;
	sta     $2005
;
; SCROLL = 0;
;
	sta     $2005
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ LoadPalette (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_LoadPalette: near

.segment	"CODE"

;
; PPU_ADDRESS = 0x3f;
;
	lda     #$3F
	sta     $2006
;
; PPU_ADDRESS = 0x00;
;
	lda     #$00
	sta     $2006
;
; for (index = 0; index < sizeof(Palette); ++index)
;
	sta     _index
L04C3:	lda     _index
	cmp     #$20
	bcs     L036A
;
; PPU_DATA = Palette[index];
;
	ldy     _index
	lda     _Palette,y
	sta     $2007
;
; for (index = 0; index < sizeof(Palette); ++index)
;
	inc     _index
	jmp     L04C3
;
; }
;
L036A:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ UpdateSprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_UpdateSprites: near

.segment	"CODE"

;
; state4 = state << 2; // shift left 2 = multiply 4
;
	lda     _state
	asl     a
	asl     a
	sta     _state4
;
; index4 = 0;
;
	lda     #$00
	sta     _index4
;
; if (direction == 0) // right
;
	lda     _direction
	jne     L04CB
;
; for (index = 0; index < 4; ++index)
;
	sta     _index
L04CA:	lda     _index
	cmp     #$04
	bcc     L04CD
;
; }
;
	rts
;
; Sprites[index4] = MetaSprite_Y[index] + Y1; // relative y + master y
;
L04CD:	lda     #<(_Sprites)
	ldx     #>(_Sprites)
	clc
	adc     _index4
	bcc     L046D
	inx
L046D:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Y,y
	clc
	adc     _Y1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; Sprites[index4] = MetaSprite_Tile_R[index + state4]; // tile numbers
;
	lda     #<(_Sprites)
	ldx     #>(_Sprites)
	clc
	adc     _index4
	bcc     L0474
	inx
L0474:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     _index
	clc
	adc     _state4
	bcc     L04C5
	inx
L04C5:	sta     ptr1
	txa
	clc
	adc     #>(_MetaSprite_Tile_R)
	sta     ptr1+1
	ldy     #<(_MetaSprite_Tile_R)
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
;
; ++index4;
;
	inc     _index4
;
; Sprites[index4] = MetaSprite_Attrib_R[index]; // attributes, all zero here
;
	lda     #<(_Sprites)
	ldx     #>(_Sprites)
	clc
	adc     _index4
	bcc     L047A
	inx
L047A:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Attrib_R,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; Sprites[index4] = MetaSprite_X[index] + X1; // relative x + master x
;
	lda     #<(_Sprites)
	ldx     #>(_Sprites)
	clc
	adc     _index4
	bcc     L0481
	inx
L0481:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_X,y
	clc
	adc     _X1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; for (index = 0; index < 4; ++index)
;
	inc     _index
	jmp     L04CA
;
; for (index = 0; index < 4; ++index)
;
L04CB:	lda     #$00
	sta     _index
L04CC:	lda     _index
	cmp     #$04
	bcc     L04CE
;
; }
;
	rts
;
; Sprites[index4] = MetaSprite_Y[index] + Y1; // relative y + master y
;
L04CE:	lda     #<(_Sprites)
	ldx     #>(_Sprites)
	clc
	adc     _index4
	bcc     L0491
	inx
L0491:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Y,y
	clc
	adc     _Y1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; Sprites[index4] = MetaSprite_Tile_L[index + state4]; // tile numbers
;
	lda     #<(_Sprites)
	ldx     #>(_Sprites)
	clc
	adc     _index4
	bcc     L0498
	inx
L0498:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     _index
	clc
	adc     _state4
	bcc     L04C8
	inx
L04C8:	sta     ptr1
	txa
	clc
	adc     #>(_MetaSprite_Tile_L)
	sta     ptr1+1
	ldy     #<(_MetaSprite_Tile_L)
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
;
; ++index4;
;
	inc     _index4
;
; Sprites[index4] = MetaSprite_Attrib_L[index]; // attributes, all zero here
;
	lda     #<(_Sprites)
	ldx     #>(_Sprites)
	clc
	adc     _index4
	bcc     L049E
	inx
L049E:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Attrib_L,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; Sprites[index4] = MetaSprite_X[index] + X1; // relative x + master x
;
	lda     #<(_Sprites)
	ldx     #>(_Sprites)
	clc
	adc     _index4
	bcc     L04A5
	inx
L04A5:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_X,y
	clc
	adc     _X1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; for (index = 0; index < 4; ++index)
;
	inc     _index
	jmp     L04CC

.endproc

; ---------------------------------------------------------------
; void __near__ CollisionDown (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_CollisionDown: near

.segment	"CODE"

;
; if (NametableB == 0) // first collision map
;
	lda     _NametableB
	bne     L0378
;
; temp = map1[collision_Index];
;
	ldy     _collision_Index
	lda     _map1,y
;
; else // second collision map
;
	jmp     L04D4
;
; temp = map2[collision_Index];
;
L0378:	ldy     _collision_Index
	lda     _map2,y
L04D4:	sta     _temp
;
; collision += Platform[temp];
;
	ldy     _temp
	lda     _Platform,y
	clc
	adc     _collision
	sta     _collision
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ MoveLogic (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_MoveLogic: near

.segment	"CODE"

;
; if ((joypad1 & (RIGHT | LEFT)) == 0) // no L or R
;
	lda     _joypad1
	and     #$03
	bne     L04E1
;
; if (X_speed >= 0) // if positive, going right
;
	ldx     _X_speed
	bmi     L0391
;
; if (X_speed >= 4)
;
	lda     _X_speed
	sec
	sbc     #$04
	bvs     L0397
	eor     #$80
L0397:	asl     a
	lda     #$00
	bcc     L04E0
;
; X_speed -= 4;
;
	lda     _X_speed
	sec
	sbc     #$04
	sta     _X_speed
	bpl     L04E1
;
; else
;
	jmp     L04E1
;
; if (X_speed <= (-4))
;
L0391:	lda     _X_speed
	sec
	sbc     #$FD
	bvc     L03A3
	eor     #$80
L03A3:	asl     a
	lda     #$00
	bcc     L04E0
;
; X_speed += 4;
;
	lda     #$04
	clc
	adc     _X_speed
	sta     _X_speed
	bpl     L04E1
;
; else
;
	jmp     L04E1
;
; X_speed = 0;
;
L04E0:	sta     _X_speed
;
; if ((joypad1 & RIGHT) != 0)
;
L04E1:	lda     _joypad1
	and     #$01
	beq     L04E2
;
; direction = 0;
;
	lda     #$00
	sta     _direction
;
; if (X_speed >= 0) // going right
;
	ldx     _X_speed
	bmi     L03B0
;
; X_speed += 2;
;
	lda     #$02
	clc
	adc     _X_speed
	sta     _X_speed
	bpl     L04E2
;
; else // going left
;
	jmp     L04E2
;
; X_speed += 8; // double friction
;
L03B0:	lda     #$08
	clc
	adc     _X_speed
	sta     _X_speed
;
; if ((joypad1 & LEFT) != 0)
;
L04E2:	lda     _joypad1
	and     #$02
	beq     L04E4
;
; direction = 1;
;
	lda     #$01
	sta     _direction
;
; if (X_speed <= 0) // going left
;
	lda     _X_speed
	sec
	sbc     #$01
	bvc     L03C3
	eor     #$80
L03C3:	bpl     L04E3
;
; X_speed -= 2;
;
	lda     _X_speed
	sec
	sbc     #$02
	sta     _X_speed
	bpl     L04E4
;
; else // going right
;
	jmp     L04E4
;
; X_speed -= 8; // double friction
;
L04E3:	lda     _X_speed
	sec
	sbc     #$08
	sta     _X_speed
;
; NametableB = Nametable;
;
L04E4:	lda     _Nametable
	sta     _NametableB
;
; Scroll_Adjusted_X = (X1 + Horiz_scroll + 3); // left
;
	ldx     #$00
	lda     _X1
	clc
	adc     _Horiz_scroll
	bcc     L04DB
	inx
	clc
L04DB:	adc     #$03
	bcc     L03D0
	inx
L03D0:	sta     _Scroll_Adjusted_X
	stx     _Scroll_Adjusted_X+1
;
; high_byte = Scroll_Adjusted_X >> 8;
;
	lda     _Scroll_Adjusted_X+1
	sta     _high_byte
;
; if (high_byte != 0) // if H scroll + Sprite X > 255, then we should use
;
	lda     _high_byte
	beq     L04E5
;
; ++NametableB;   // the other nametable's collision map
;
	inc     _NametableB
;
; NametableB &= 1; // keep it 0 or 1
;
	lda     _NametableB
	and     #$01
	sta     _NametableB
;
; collision_Index = (((char)Scroll_Adjusted_X >> 4) + ((Y1 + 16) & 0xf0));
;
L04E5:	lda     _Scroll_Adjusted_X
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _Y1
	clc
	adc     #$10
	and     #$F0
	clc
	adc     ptr1
	sta     _collision_Index
;
; collision = 0;
;
	lda     #$00
	sta     _collision
;
; CollisionDown(); // if on platform, ++collision
;
	jsr     _CollisionDown
;
; NametableB = Nametable;
;
	lda     _Nametable
	sta     _NametableB
;
; Scroll_Adjusted_X = (X1 + Horiz_scroll + 12);
;
	ldx     #$00
	lda     _X1
	clc
	adc     _Horiz_scroll
	bcc     L04DC
	inx
	clc
L04DC:	adc     #$0C
	bcc     L03E7
	inx
L03E7:	sta     _Scroll_Adjusted_X
	stx     _Scroll_Adjusted_X+1
;
; high_byte = Scroll_Adjusted_X >> 8;
;
	lda     _Scroll_Adjusted_X+1
	sta     _high_byte
;
; if (high_byte != 0) // if H scroll + Sprite X > 255, then we should use
;
	lda     _high_byte
	beq     L04E6
;
; ++NametableB;   // the other nametable's collision map
;
	inc     _NametableB
;
; NametableB &= 1; // keep it 0 or 1
;
	lda     _NametableB
	and     #$01
	sta     _NametableB
;
; collision_Index = (((char)Scroll_Adjusted_X >> 4) + ((Y1 + 16) & 0xf0)); // bottom right
;
L04E6:	lda     _Scroll_Adjusted_X
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _Y1
	clc
	adc     #$10
	and     #$F0
	clc
	adc     ptr1
	sta     _collision_Index
;
; CollisionDown(); // if on platform, ++collision
;
	jsr     _CollisionDown
;
; if ((Y1 & 0x0f) > 1) // only platform collide if nearly aligned to a metatile
;
	lda     _Y1
	and     #$0F
	cmp     #$02
	bcc     L04E7
;
; collision = 0;
;
	lda     #$00
	sta     _collision
;
; if (collision == 0)
;
L04E7:	lda     _collision
	bne     L04E8
;
; Y_speed += 2; // gravity
;
	lda     #$02
	clc
	adc     _Y_speed
	sta     _Y_speed
	bpl     L04E9
;
; else
;
	jmp     L04E9
;
; Y_speed = 0; // collision = stop falling
;
L04E8:	lda     #$00
	sta     _Y_speed
;
; Y1 &= 0xf0; // align to the metatile
;
	lda     _Y1
	and     #$F0
	sta     _Y1
;
; if (collision > 0)
;
L04E9:	lda     _collision
	beq     L04ED
;
; if (((joypad1 & A_BUTTON) != 0) && ((joypad1old & A_BUTTON) == 0))
;
	lda     _joypad1
	and     #$80
	beq     L04ED
	lda     _joypad1old
	and     #$80
	bne     L04ED
;
; Y_speed = -0x38; // 0xc8
;
	lda     #$C8
	sta     _Y_speed
;
; if (X_speed >= 0) // going right
;
L04ED:	ldx     _X_speed
	bmi     L0414
;
; if (X_speed > 0x20)
;
	lda     _X_speed
	sec
	sbc     #$21
	bvs     L041A
	eor     #$80
L041A:	bpl     L04EE
;
; X_speed = 0x20;
;
	lda     #$20
;
; else
;
	jmp     L04D9
;
; if (X_speed < (-0x20))
;
L0414:	lda     _X_speed
	sec
	sbc     #$E0
	bvc     L0422
	eor     #$80
L0422:	bpl     L04EE
;
; X_speed = (-0x20); // 0xe0
;
	lda     #$E0
L04D9:	sta     _X_speed
;
; if (Y_speed >= 0)
;
L04EE:	ldx     _Y_speed
	bmi     L04EF
;
; if (Y_speed > 0x20)
;
	lda     _Y_speed
	sec
	sbc     #$21
	bvs     L042C
	eor     #$80
L042C:	bpl     L04EF
;
; Y_speed = 0x20;
;
	lda     #$20
	sta     _Y_speed
;
; Horiz_scroll_Old = Horiz_scroll;
;
L04EF:	lda     _Horiz_scroll
	sta     _Horiz_scroll_Old
;
; Horiz_scroll += (X_speed >> 4); // use the high nibble
;
	ldx     #$00
	lda     _X_speed
	bpl     L0434
	dex
L0434:	jsr     asrax4
	clc
	adc     _Horiz_scroll
	sta     _Horiz_scroll
;
; if (X_speed >= 0) // going right
;
	ldx     _X_speed
	bmi     L0435
;
; if (Horiz_scroll_Old > Horiz_scroll) // if pass 0, switch nametables
;
	ldx     #$00
	lda     _Horiz_scroll_Old
	sec
	sbc     _Horiz_scroll
	bcc     L04F0
	beq     L04F0
;
; else // going left
;
	jmp     L04F3
;
; if (Horiz_scroll_Old < Horiz_scroll)
;
L0435:	ldx     #$00
	lda     _Horiz_scroll_Old
	cmp     _Horiz_scroll
	bcs     L04F0
;
; ++Nametable; // if pass 0, switch nametables
;
L04F3:	inc     _Nametable
;
; Nametable &= 1; // keep it 1 or 0
;
L04F0:	lda     _Nametable
	and     #$01
	sta     _Nametable
;
; Y1 += (Y_speed >> 4); // use the high nibble
;
	lda     _Y_speed
	bpl     L0444
	dex
L0444:	jsr     asrax4
	clc
	adc     _Y1
	sta     _Y1
;
; ComputeAnimation();
;
	jmp     _ComputeAnimation

.endproc

; ---------------------------------------------------------------
; void __near__ ComputeAnimation (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ComputeAnimation: near

.segment	"CODE"

;
; if (Y_speed == 0)
;
	lda     _Y_speed
	bne     L0447
;
; if (X_speed == 0)
;
	lda     _X_speed
	bne     L044A
;
; walk_count = 0;
;
	sta     _walk_count
;
; else
;
	rts
;
; ++walk_count;
;
L044A:	inc     _walk_count
;
; if (walk_count > MAX_WALK_COUNT) // walk_count forced 0-31
;
	lda     _walk_count
	cmp     #$20
	ldx     #$00
	bcc     L04F5
;
; walk_count = 0;
;
	stx     _walk_count
;
; state = Walk_Moves[(walk_count >> 3)]; // if not jumping
;
L04F5:	lda     _walk_count
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	txa
	clc
	adc     #>(_Walk_Moves)
	sta     ptr1+1
	ldy     #<(_Walk_Moves)
	lda     (ptr1),y
;
; else
;
	jmp     L04F4
;
; state = 3;
;
L0447:	lda     #$03
L04F4:	sta     _state
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ DrawBackground (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_DrawBackground: near

.segment	"CODE"

;
; PPU_ADDRESS = 0x20; // address of nametable #0 = 0x2000
;
	lda     #$20
	sta     $2006
;
; PPU_ADDRESS = 0x00;
;
	lda     #$00
	sta     $2006
;
; UnRLE(N1); // uncompresses our data
;
	lda     #<(_N1)
	ldx     #>(_N1)
	jsr     _UnRLE
;
; PPU_ADDRESS = 0x24; // address of nametable #1 = 0x2400
;
	lda     #$24
	sta     $2006
;
; PPU_ADDRESS = 0x00;
;
	lda     #$00
	sta     $2006
;
; UnRLE(N2); // uncompresses our data
;
	lda     #<(_N2)
	ldx     #>(_N2)
	jsr     _UnRLE
;
; memcpy(map1, C1, 240);
;
	lda     #<(_map1)
	ldx     #>(_map1)
	jsr     pushax
	lda     #<(_C1)
	ldx     #>(_C1)
	jsr     pushax
	ldx     #$00
	lda     #$F0
	jsr     _memcpy
;
; memcpy(map2, C2, 240);
;
	lda     #<(_map2)
	ldx     #>(_map2)
	jsr     pushax
	lda     #<(_C2)
	ldx     #>(_C2)
	jsr     pushax
	ldx     #$00
	lda     #$F0
	jmp     _memcpy

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; AllOff(); // turn off screen
;
	jsr     _AllOff
;
; DrawBackground();
;
	jsr     _DrawBackground
;
; X1 = 0x80;
;
	lda     #$80
	sta     _X1
;
; Y1 = 0x70; // middle of screen
;
	lda     #$70
	sta     _Y1
;
; LoadPalette();
;
	jsr     _LoadPalette
;
; ResetScroll();
;
	jsr     _ResetScroll
;
; Wait_Vblank();
;
	jsr     _Wait_Vblank
;
; AllOn(); // turn on screen
;
	jsr     _AllOn
;
; while (NMI_flag == 0); // wait till NMI
;
L04F6:	lda     _NMI_flag
	beq     L04F6
;
; Get_Input();
;
	jsr     _Get_Input
;
; MoveLogic();
;
	jsr     _MoveLogic
;
; UpdateSprites();
;
	jsr     _UpdateSprites
;
; NMI_flag = 0;
;
	lda     #$00
	sta     _NMI_flag
;
; while (1) // infinite loop
;
	jmp     L04F6

.endproc


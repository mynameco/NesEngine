;
; File generated by cc65 v 2.16 - Git 83890e5
;
	.fopt		compiler,"cc65 v 2.16 - Git 83890e5"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_NMI_flag
	.export		_Frame_Count
	.export		_index
	.export		_index2
	.export		_index3
	.export		_index4
	.export		_X1
	.export		_Y1
	.export		_state
	.export		_state4
	.export		_joypad1
	.export		_joypad1old
	.export		_joypad1test
	.export		_joypad2
	.export		_joypad2old
	.export		_joypad2test
	.export		_Room
	.export		_RoomB
	.export		_RoomPlus
	.export		_Room_Address
	.export		_Horiz_scroll
	.export		_Horiz_scroll_Old
	.export		_Horiz_scroll_Plus
	.export		_Scroll_Adjusted_X
	.export		_Nametable
	.export		_NametableB
	.export		_Nametable_Plus
	.export		_walk_count
	.export		_X_speed
	.export		_Y_speed
	.export		_direction
	.export		_collision_Index
	.export		_high_byte
	.export		_collision
	.export		_temp
	.export		_temp2
	.export		_temp3
	.export		_temp4
	.export		_PPU_ADDRESS_High
	.export		_PPU_ADDRESS_Low
	.export		_A
	.export		_PPU_flag
	.export		_PPU_flag2
	.export		_dummy
	.export		_SPRITE_ZERO
	.export		_SPRITES
	.export		_C_MAP
	.export		_C_MAP2
	.export		_BUFFER1
	.export		_BUFFER2
	.export		_BUFFER3
	.export		_BUFFER4
	.export		_BUFFER5
	.export		_BUFFER6
	.export		_BUFFER7
	.export		_A1
	.export		_A2
	.export		_A3
	.export		_A4
	.export		_ROOMS
	.export		_PLATFORM
	.export		_METATILES
	.export		_MT_color
	.export		_HUD
	.export		_PALETTE
	.export		_Walk_Moves
	.export		_MetaSprite_Y
	.export		_MetaSprite_Tile_Right
	.export		_MetaSprite_Attrib_Right
	.export		_MetaSprite_X
	.export		_MetaSprite_Tile_Left
	.export		_MetaSprite_Attrib_Left
	.export		_AllOff
	.export		_AllOn
	.export		_ResetScroll
	.export		_LoadPalette
	.export		_UpdateSprites
	.export		_CollisionDown
	.export		_MoveLogic
	.export		_DoBuffer
	.export		_DoBuffer2
	.export		_DoBuffer3
	.export		_DrawBackground
	.export		_SetSpriteZero
	.export		_LoadHud
	.export		_ShouldWeBuffer
	.export		_NewRoom
	.import		_memcpy
	.import		_Wait_Vblank
	.import		_Get_Input
	.import		_Sprite_Zero
	.import		_Super_Fast_Write_PPU
	.import		_Super_Fast_Write_PPU2
	.export		_BufferTiles
	.export		_BufferTiles2
	.export		_main

.segment	"RODATA"

_A1:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$03
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$09
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0B
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
_A2:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$03
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$06
	.byte	$07
	.byte	$07
	.byte	$07
	.byte	$08
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$09
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0B
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
_A3:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
_A4:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$03
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$04
	.byte	$05
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$06
	.byte	$07
	.byte	$07
	.byte	$07
	.byte	$07
	.byte	$07
	.byte	$07
	.byte	$07
	.byte	$07
	.byte	$08
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$09
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0A
	.byte	$0B
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
_ROOMS:
	.addr	_A1
	.addr	_A2
	.addr	_A3
	.addr	_A4
_PLATFORM:
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_METATILES:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$02
	.byte	$14
	.byte	$14
	.byte	$14
	.byte	$14
	.byte	$05
	.byte	$06
	.byte	$15
	.byte	$16
	.byte	$06
	.byte	$06
	.byte	$16
	.byte	$16
	.byte	$06
	.byte	$07
	.byte	$16
	.byte	$17
	.byte	$15
	.byte	$16
	.byte	$15
	.byte	$16
	.byte	$16
	.byte	$16
	.byte	$16
	.byte	$16
	.byte	$16
	.byte	$17
	.byte	$16
	.byte	$17
	.byte	$15
	.byte	$16
	.byte	$18
	.byte	$19
	.byte	$16
	.byte	$16
	.byte	$19
	.byte	$19
	.byte	$16
	.byte	$17
	.byte	$19
	.byte	$1A
_MT_color:
	.byte	$00
	.byte	$03
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
	.byte	$01
_HUD:
	.byte	$54,$45,$53,$54,$20,$53,$50,$52,$49,$54,$45,$20,$5A,$45,$52,$4F
	.byte	$20,$48,$45,$52,$45,$20,$20,$00
_PALETTE:
	.byte	$22
	.byte	$16
	.byte	$36
	.byte	$0F
	.byte	$00
	.byte	$08
	.byte	$18
	.byte	$39
	.byte	$00
	.byte	$00
	.byte	$10
	.byte	$20
	.byte	$00
	.byte	$0A
	.byte	$1A
	.byte	$2A
	.byte	$22
	.byte	$37
	.byte	$16
	.byte	$0F
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$05
	.byte	$15
_Walk_Moves:
	.byte	$00
	.byte	$01
	.byte	$00
	.byte	$02
_MetaSprite_Y:
	.byte	$00
	.byte	$00
	.byte	$08
	.byte	$08
_MetaSprite_Tile_Right:
	.byte	$00
	.byte	$01
	.byte	$10
	.byte	$11
	.byte	$02
	.byte	$03
	.byte	$12
	.byte	$13
	.byte	$04
	.byte	$05
	.byte	$14
	.byte	$15
	.byte	$06
	.byte	$07
	.byte	$16
	.byte	$17
_MetaSprite_Attrib_Right:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_MetaSprite_X:
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$08
_MetaSprite_Tile_Left:
	.byte	$01
	.byte	$00
	.byte	$11
	.byte	$10
	.byte	$03
	.byte	$02
	.byte	$13
	.byte	$12
	.byte	$05
	.byte	$04
	.byte	$15
	.byte	$14
	.byte	$07
	.byte	$06
	.byte	$17
	.byte	$16
_MetaSprite_Attrib_Left:
	.byte	$40
	.byte	$40
	.byte	$40
	.byte	$40

.segment	"BSS"

.segment	"ZEROPAGE"
_NMI_flag:
	.res	1,$00
_Frame_Count:
	.res	1,$00
_index:
	.res	1,$00
_index2:
	.res	1,$00
_index3:
	.res	1,$00
_index4:
	.res	1,$00
_X1:
	.res	1,$00
_Y1:
	.res	1,$00
_state:
	.res	1,$00
_state4:
	.res	1,$00
_joypad1:
	.res	1,$00
_joypad1old:
	.res	1,$00
_joypad1test:
	.res	1,$00
_joypad2:
	.res	1,$00
_joypad2old:
	.res	1,$00
_joypad2test:
	.res	1,$00
_Room:
	.res	1,$00
_RoomB:
	.res	1,$00
_RoomPlus:
	.res	1,$00
_Room_Address:
	.res	2,$00
_Horiz_scroll:
	.res	1,$00
_Horiz_scroll_Old:
	.res	1,$00
_Horiz_scroll_Plus:
	.res	1,$00
_Scroll_Adjusted_X:
	.res	2,$00
_Nametable:
	.res	1,$00
_NametableB:
	.res	1,$00
_Nametable_Plus:
	.res	1,$00
_walk_count:
	.res	1,$00
_X_speed:
	.res	1,$00
_Y_speed:
	.res	1,$00
_direction:
	.res	1,$00
_collision_Index:
	.res	1,$00
_high_byte:
	.res	1,$00
_collision:
	.res	1,$00
_temp:
	.res	1,$00
_temp2:
	.res	1,$00
_temp3:
	.res	1,$00
_temp4:
	.res	1,$00
_PPU_ADDRESS_High:
	.res	1,$00
_PPU_ADDRESS_Low:
	.res	1,$00
_A:
	.res	1,$00
_PPU_flag:
	.res	1,$00
_PPU_flag2:
	.res	1,$00
_dummy:
	.res	1,$00
.segment	"OAM"
_SPRITE_ZERO:
	.res	4,$00
_SPRITES:
	.res	252,$00
.segment	"MAP"
_C_MAP:
	.res	256,$00
_C_MAP2:
	.res	256,$00
.segment	"BSS"
_BUFFER1:
	.res	32,$00
_BUFFER2:
	.res	32,$00
_BUFFER3:
	.res	32,$00
_BUFFER4:
	.res	32,$00
_BUFFER5:
	.res	8,$00
_BUFFER6:
	.res	8,$00
_BUFFER7:
	.res	8,$00

; ---------------------------------------------------------------
; void __near__ AllOff (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_AllOff: near

.segment	"CODE"

;
; PPU_CTRL = 0;
;
	lda     #$00
	sta     $2000
;
; PPU_MASK = 0;
;
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ AllOn (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_AllOn: near

.segment	"CODE"

;
; PPU_CTRL = 0x94; // screen is on, NMI on
;
	lda     #$94
	sta     $2000
;
; PPU_MASK = 0x1e;
;
	lda     #$1E
	sta     $2001
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ResetScroll (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ResetScroll: near

.segment	"CODE"

;
; PPU_ADDRESS = 0;
;
	lda     #$00
	sta     $2006
;
; PPU_ADDRESS = 0;
;
	sta     $2006
;
; SCROLL = 0;
;
	sta     $2005
;
; SCROLL = 0;
;
	sta     $2005
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ LoadPalette (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_LoadPalette: near

.segment	"CODE"

;
; PPU_ADDRESS = 0x3f;
;
	lda     #$3F
	sta     $2006
;
; PPU_ADDRESS = 0x00;
;
	lda     #$00
	sta     $2006
;
; for (index = 0; index < sizeof(PALETTE); ++index)
;
	sta     _index
L083F:	lda     _index
	cmp     #$20
	bcs     L05F0
;
; PPU_DATA = PALETTE[index];
;
	ldy     _index
	lda     _PALETTE,y
	sta     $2007
;
; for (index = 0; index < sizeof(PALETTE); ++index)
;
	inc     _index
	jmp     L083F
;
; }
;
L05F0:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ UpdateSprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_UpdateSprites: near

.segment	"CODE"

;
; state4 = state << 2; // shift left 2 = multiply 4
;
	lda     _state
	asl     a
	asl     a
	sta     _state4
;
; index4 = 0;
;
	lda     #$00
	sta     _index4
;
; if (direction == 0)
;
	lda     _direction
	jne     L0847
;
; for (index = 0; index < 4; ++index)
;
	sta     _index
L0846:	lda     _index
	cmp     #$04
	bcc     L0849
;
; }
;
	rts
;
; SPRITES[index4] = MetaSprite_Y[index] + Y1; // relative y + master y
;
L0849:	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L060E
	inx
L060E:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Y,y
	clc
	adc     _Y1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Tile_Right[index + state4]; // tile numbers
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0615
	inx
L0615:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     _index
	clc
	adc     _state4
	bcc     L0841
	inx
L0841:	sta     ptr1
	txa
	clc
	adc     #>(_MetaSprite_Tile_Right)
	sta     ptr1+1
	ldy     #<(_MetaSprite_Tile_Right)
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Attrib_Right[index]; // attributes, all zero here
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L061B
	inx
L061B:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Attrib_Right,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_X[index] + X1; // relative x + master x
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0622
	inx
L0622:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_X,y
	clc
	adc     _X1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; for (index = 0; index < 4; ++index)
;
	inc     _index
	jmp     L0846
;
; for (index = 0; index < 4; ++index)
;
L0847:	lda     #$00
	sta     _index
L0848:	lda     _index
	cmp     #$04
	bcc     L084A
;
; }
;
	rts
;
; SPRITES[index4] = MetaSprite_Y[index] + Y1; // relative y + master y
;
L084A:	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0632
	inx
L0632:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Y,y
	clc
	adc     _Y1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Tile_Left[index + state4]; // tile numbers
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0639
	inx
L0639:	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     _index
	clc
	adc     _state4
	bcc     L0844
	inx
L0844:	sta     ptr1
	txa
	clc
	adc     #>(_MetaSprite_Tile_Left)
	sta     ptr1+1
	ldy     #<(_MetaSprite_Tile_Left)
	lda     (ptr1),y
	ldy     #$00
	sta     (sreg),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_Attrib_Left[index]; // attributes, all zero here
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L063F
	inx
L063F:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_Attrib_Left,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; SPRITES[index4] = MetaSprite_X[index] + X1; // relative x + master x
;
	lda     #<(_SPRITES)
	ldx     #>(_SPRITES)
	clc
	adc     _index4
	bcc     L0646
	inx
L0646:	sta     ptr1
	stx     ptr1+1
	ldy     _index
	lda     _MetaSprite_X,y
	clc
	adc     _X1
	ldy     #$00
	sta     (ptr1),y
;
; ++index4;
;
	inc     _index4
;
; for (index = 0; index < 4; ++index)
;
	inc     _index
	jmp     L0848

.endproc

; ---------------------------------------------------------------
; void __near__ CollisionDown (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_CollisionDown: near

.segment	"CODE"

;
; if (NametableB == 0)
;
	lda     _NametableB
	bne     L064C
;
; temp = C_MAP[collision_Index];
;
	ldy     _collision_Index
	lda     _C_MAP,y
;
; else
;
	jmp     L0850
;
; temp = C_MAP2[collision_Index];
;
L064C:	ldy     _collision_Index
	lda     _C_MAP2,y
L0850:	sta     _temp
;
; collision += PLATFORM[temp];
;
	ldy     _temp
	lda     _PLATFORM,y
	clc
	adc     _collision
	sta     _collision
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ MoveLogic (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_MoveLogic: near

.segment	"CODE"

;
; if ((joypad1 & (RIGHT | LEFT)) == 0)
;
	lda     _joypad1
	and     #$03
	bne     L085C
;
; walk_count = 0;
;
	sta     _walk_count
;
; if (X_speed >= 0)
;
	ldx     _X_speed
	bmi     L0667
;
; if (X_speed >= 4)
;
	lda     _X_speed
	sec
	sbc     #$04
	bvs     L066D
	eor     #$80
L066D:	asl     a
	lda     #$00
	bcc     L085B
;
; X_speed -= 4;
;
	lda     _X_speed
	sec
	sbc     #$04
	sta     _X_speed
	bpl     L085C
;
; else
;
	jmp     L085C
;
; if (X_speed <= (-4))
;
L0667:	lda     _X_speed
	sec
	sbc     #$FD
	bvc     L0679
	eor     #$80
L0679:	asl     a
	lda     #$00
	bcc     L085B
;
; X_speed += 4;
;
	lda     #$04
	clc
	adc     _X_speed
	sta     _X_speed
	bpl     L085C
;
; else
;
	jmp     L085C
;
; X_speed = 0; // just stop
;
L085B:	sta     _X_speed
;
; if ((joypad1 & RIGHT) != 0)
;
L085C:	lda     _joypad1
	and     #$01
	beq     L085E
;
; ++walk_count;
;
	inc     _walk_count
;
; direction = 0;
;
	lda     #$00
	sta     _direction
;
; if (X_speed >= 0)
;
	ldx     _X_speed
	bmi     L0687
;
; X_speed += 2;
;
	lda     #$02
	clc
	adc     _X_speed
	sta     _X_speed
	bpl     L085E
;
; else
;
	jmp     L085E
;
; X_speed += 8; // just stop
;
L0687:	lda     #$08
	clc
	adc     _X_speed
	sta     _X_speed
;
; if (X_speed >= 0)
;
	tax
	bmi     L085E
;
; X_speed = 0;
;
	lda     #$00
	sta     _X_speed
;
; if ((joypad1 & LEFT) != 0)
;
L085E:	lda     _joypad1
	and     #$02
	beq     L0861
;
; ++walk_count;
;
	inc     _walk_count
;
; direction = 1;
;
	lda     #$01
	sta     _direction
;
; if (X_speed <= 0)
;
	lda     _X_speed
	sec
	sbc     #$01
	bvc     L06A0
	eor     #$80
L06A0:	bpl     L085F
;
; X_speed -= 2;
;
	lda     _X_speed
	sec
	sbc     #$02
	sta     _X_speed
	bpl     L0861
;
; else
;
	jmp     L0861
;
; X_speed -= 8;//just stop
;
L085F:	lda     _X_speed
	sec
	sbc     #$08
	sta     _X_speed
;
; if (X_speed < 0)
;
	asl     a
	bcc     L0861
;
; X_speed = 0;
;
	lda     #$00
	sta     _X_speed
;
; NametableB = Nametable;
;
L0861:	lda     _Nametable
	sta     _NametableB
;
; Scroll_Adjusted_X = (X1 + Horiz_scroll + 3); //left
;
	ldx     #$00
	lda     _X1
	clc
	adc     _Horiz_scroll
	bcc     L0856
	inx
	clc
L0856:	adc     #$03
	bcc     L06B2
	inx
L06B2:	sta     _Scroll_Adjusted_X
	stx     _Scroll_Adjusted_X+1
;
; high_byte = Scroll_Adjusted_X >> 8;
;
	lda     _Scroll_Adjusted_X+1
	sta     _high_byte
;
; if (high_byte != 0)
;
	lda     _high_byte
	beq     L0862
;
; ++NametableB;    // the other nametable's collision map
;
	inc     _NametableB
;
; NametableB &= 1; // keep it 0 or 1
;
	lda     _NametableB
	and     #$01
	sta     _NametableB
;
; collision_Index = (((char)Scroll_Adjusted_X >> 4) + ((Y1 + 16) & 0xf0)); // bottom left
;
L0862:	lda     _Scroll_Adjusted_X
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _Y1
	clc
	adc     #$10
	and     #$F0
	clc
	adc     ptr1
	sta     _collision_Index
;
; collision = 0;
;
	lda     #$00
	sta     _collision
;
; CollisionDown();
;
	jsr     _CollisionDown
;
; NametableB = Nametable;
;
	lda     _Nametable
	sta     _NametableB
;
; Scroll_Adjusted_X = (X1 + Horiz_scroll + 12); // right
;
	ldx     #$00
	lda     _X1
	clc
	adc     _Horiz_scroll
	bcc     L0857
	inx
	clc
L0857:	adc     #$0C
	bcc     L06C9
	inx
L06C9:	sta     _Scroll_Adjusted_X
	stx     _Scroll_Adjusted_X+1
;
; high_byte = Scroll_Adjusted_X >> 8;
;
	lda     _Scroll_Adjusted_X+1
	sta     _high_byte
;
; if (high_byte != 0)
;
	lda     _high_byte
	beq     L0863
;
; ++NametableB;    // the other nametable's collision map
;
	inc     _NametableB
;
; NametableB &= 1; // keep it 0 or 1
;
	lda     _NametableB
	and     #$01
	sta     _NametableB
;
; collision_Index = (((char)Scroll_Adjusted_X >> 4) + ((Y1 + 16) & 0xf0)); // bottom right
;
L0863:	lda     _Scroll_Adjusted_X
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	lda     _Y1
	clc
	adc     #$10
	and     #$F0
	clc
	adc     ptr1
	sta     _collision_Index
;
; CollisionDown();
;
	jsr     _CollisionDown
;
; if ((Y1 & 0x0f) > 1) // only platform collide if nearly aligned to a metatile
;
	lda     _Y1
	and     #$0F
	cmp     #$02
	bcc     L0864
;
; collision = 0;
;
	lda     #$00
	sta     _collision
;
; if (collision == 0)
;
L0864:	lda     _collision
	bne     L0865
;
; Y_speed += 2; // gravity
;
	lda     #$02
	clc
	adc     _Y_speed
	sta     _Y_speed
	bpl     L0866
;
; else
;
	jmp     L0866
;
; Y_speed = 0; // collision = stop falling
;
L0865:	lda     #$00
	sta     _Y_speed
;
; Y1 &= 0xf0;  // align to the metatile
;
	lda     _Y1
	and     #$F0
	sta     _Y1
;
; if (collision > 0)
;
L0866:	lda     _collision
	beq     L086A
;
; if (((joypad1 & A_BUTTON) != 0) && ((joypad1old & A_BUTTON) == 0))
;
	lda     _joypad1
	and     #$80
	beq     L086A
	lda     _joypad1old
	and     #$80
	bne     L086A
;
; Y_speed = -0x38; // -0x38
;
	lda     #$C8
	sta     _Y_speed
;
; if (X_speed >= 0)
;
L086A:	ldx     _X_speed
	bmi     L06F6
;
; if (X_speed > 0x20)
;
	lda     _X_speed
	sec
	sbc     #$21
	bvs     L06FC
	eor     #$80
L06FC:	bpl     L086B
;
; X_speed = 0x20;
;
	lda     #$20
;
; else
;
	jmp     L0853
;
; if (X_speed < -0x20)
;
L06F6:	lda     _X_speed
	sec
	sbc     #$E0
	bvc     L0703
	eor     #$80
L0703:	bpl     L086B
;
; X_speed = -0x20; // -0x20
;
	lda     #$E0
L0853:	sta     _X_speed
;
; if (Y_speed >= 0)
;
L086B:	ldx     _Y_speed
	bmi     L086C
;
; if (Y_speed > 0x20)
;
	lda     _Y_speed
	sec
	sbc     #$21
	bvs     L070C
	eor     #$80
L070C:	bpl     L086C
;
; Y_speed = 0x20;
;
	lda     #$20
	sta     _Y_speed
;
; Horiz_scroll_Old = Horiz_scroll;
;
L086C:	lda     _Horiz_scroll
	sta     _Horiz_scroll_Old
;
; if (X_speed >= 0)
;
	ldx     _X_speed
	bmi     L0711
;
; if (X1 < 0x80)
;
	ldx     #$00
	lda     _X1
	cmp     #$80
	bcs     L086D
;
; X1 += (X_speed >> 4); // use the high nibble
;
	lda     _X_speed
	bpl     L0719
	dex
L0719:	jsr     asrax4
	clc
	adc     _X1
	sta     _X1
;
; if (X1 > 0x80)
;
	cmp     #$81
	bcc     L086E
;
; X1 = 0x80;
;
	lda     #$80
;
; else
;
	jmp     L0854
;
; Horiz_scroll += (X_speed >> 4); // use the high nibble
;
L086D:	lda     _X_speed
	bpl     L0722
	dex
L0722:	jsr     asrax4
	clc
	adc     _Horiz_scroll
	sta     _Horiz_scroll
;
; if (Horiz_scroll_Old > Horiz_scroll)
;
	lda     _Horiz_scroll_Old
	sec
	sbc     _Horiz_scroll
	bcc     L086E
	beq     L086E
;
; ++Nametable;
;
	inc     _Nametable
;
; ++Room;
;
	inc     _Room
;
; else
;
	jmp     L086E
;
; X1 += (X_speed >> 4); // use the high nibble
;
L0711:	ldx     #$00
	lda     _X_speed
	bpl     L072B
	dex
L072B:	jsr     asrax4
	clc
	adc     _X1
	sta     _X1
;
; if (X1 > 0xc0)
;
	cmp     #$C1
	bcc     L086E
;
; X1 = 0;
;
	lda     #$00
L0854:	sta     _X1
;
; Nametable &= 1; // keep it 1 or 0
;
L086E:	lda     _Nametable
	and     #$01
	sta     _Nametable
;
; Room &= 3; // keep it 0-3
;
	lda     _Room
	and     #$03
	sta     _Room
;
; Y1 += (Y_speed >> 4); // use the high nibble
;
	ldx     #$00
	lda     _Y_speed
	bpl     L073F
	dex
L073F:	jsr     asrax4
	clc
	adc     _Y1
	sta     _Y1
;
; if (walk_count > 0x1f) // walk_count forced 0-1f
;
	lda     _walk_count
	cmp     #$20
	ldx     #$00
	bcc     L086F
;
; walk_count = 0;
;
	stx     _walk_count
;
; state = Walk_Moves[(walk_count >> 3)]; // if not jumping
;
L086F:	lda     _walk_count
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	txa
	clc
	adc     #>(_Walk_Moves)
	sta     ptr1+1
	ldy     #<(_Walk_Moves)
	lda     (ptr1),y
	sta     _state
;
; if (Y_speed < 0) // negative = jumping
;
	lda     _Y_speed
	asl     a
	bcc     L0748
;
; state = 3;
;
	lda     #$03
	sta     _state
;
; }
;
L0748:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ DoBuffer (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_DoBuffer: near

.segment	"CODE"

;
; BufferTiles();
;
	jsr     _BufferTiles
;
; Horiz_scroll_Plus += 0x10;
;
	lda     #$10
	clc
	adc     _Horiz_scroll_Plus
	sta     _Horiz_scroll_Plus
;
; BufferTiles2();
;
	jsr     _BufferTiles2
;
; Horiz_scroll_Plus -= 0x10;
;
	lda     _Horiz_scroll_Plus
	sec
	sbc     #$10
	sta     _Horiz_scroll_Plus
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ DoBuffer2 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_DoBuffer2: near

.segment	"CODE"

;
; if (Nametable_Plus == 0)
;
	lda     _Nametable_Plus
	bne     L0878
;
; PPU_ADDRESS_High = 0x24;
;
	lda     #$24
;
; else
;
	jmp     L0877
;
; PPU_ADDRESS_High = 0x20;
;
L0878:	lda     #$20
L0877:	sta     _PPU_ADDRESS_High
;
; PPU_ADDRESS_Low = ((Horiz_scroll_Plus & 0xf0) >> 3) + 0x80; // +80 because we're skipping the top
;
	lda     _Horiz_scroll_Plus
	and     #$F0
	lsr     a
	lsr     a
	lsr     a
	clc
	adc     #$80
	sta     _PPU_ADDRESS_Low
;
; PPU_ADDRESS = PPU_ADDRESS_High;
;
	lda     _PPU_ADDRESS_High
	sta     $2006
;
; PPU_ADDRESS = PPU_ADDRESS_Low;
;
	lda     _PPU_ADDRESS_Low
	sta     $2006
;
; Super_Fast_Write_PPU();
;
	jmp     _Super_Fast_Write_PPU

.endproc

; ---------------------------------------------------------------
; void __near__ DoBuffer3 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_DoBuffer3: near

.segment	"CODE"

;
; if (Nametable_Plus == 0)
;
	lda     _Nametable_Plus
	bne     L087A
;
; PPU_ADDRESS_High = 0x24;
;
	lda     #$24
;
; else
;
	jmp     L0879
;
; PPU_ADDRESS_High = 0x20;
;
L087A:	lda     #$20
L0879:	sta     _PPU_ADDRESS_High
;
; PPU_ADDRESS_Low = ((Horiz_scroll_Plus & 0xf0) >> 3) + 0x80; // +80 because we're skipping the top
;
	lda     _Horiz_scroll_Plus
	and     #$F0
	lsr     a
	lsr     a
	lsr     a
	clc
	adc     #$80
	sta     _PPU_ADDRESS_Low
;
; PPU_ADDRESS = PPU_ADDRESS_High;
;
	lda     _PPU_ADDRESS_High
	sta     $2006
;
; PPU_ADDRESS = PPU_ADDRESS_Low;
;
	lda     _PPU_ADDRESS_Low
	sta     $2006
;
; Super_Fast_Write_PPU2();
;
	jmp     _Super_Fast_Write_PPU2

.endproc

; ---------------------------------------------------------------
; void __near__ DrawBackground (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_DrawBackground: near

.segment	"CODE"

;
; memcpy(C_MAP, A1, 240);
;
	lda     #<(_C_MAP)
	ldx     #>(_C_MAP)
	jsr     pushax
	lda     #<(_A1)
	ldx     #>(_A1)
	jsr     pushax
	ldx     #$00
	lda     #$F0
	jsr     _memcpy
;
; memcpy(C_MAP2, A2, 240);
;
	lda     #<(_C_MAP2)
	ldx     #>(_C_MAP2)
	jsr     pushax
	lda     #<(_A2)
	ldx     #>(_A2)
	jsr     pushax
	ldx     #$00
	lda     #$F0
	jsr     _memcpy
;
; Nametable_Plus = 1;
;
	lda     #$01
	sta     _Nametable_Plus
;
; PPU_CTRL = 4; // sets to downward increments when writing to PPU
;
	lda     #$04
	sta     $2000
;
; for (A = 0; A < 8; ++A)
;
	lda     #$00
	sta     _A
L087B:	lda     _A
	cmp     #$08
	bcs     L087C
;
; DoBuffer(); // fill buffer
;
	jsr     _DoBuffer
;
; DoBuffer2(); // draw to ppu
;
	jsr     _DoBuffer2
;
; Horiz_scroll_Plus += 0x10;
;
	lda     #$10
	clc
	adc     _Horiz_scroll_Plus
	sta     _Horiz_scroll_Plus
;
; DoBuffer3(); // draw to ppu
;
	jsr     _DoBuffer3
;
; Horiz_scroll_Plus += 0x10;
;
	lda     #$10
	clc
	adc     _Horiz_scroll_Plus
	sta     _Horiz_scroll_Plus
;
; for (A = 0; A < 8; ++A)
;
	inc     _A
	jmp     L087B
;
; --Nametable_Plus;
;
L087C:	dec     _Nametable_Plus
;
; for (A = 0; A < 8; ++A)
;
	lda     #$00
	sta     _A
L087D:	lda     _A
	cmp     #$08
	bcs     L079B
;
; DoBuffer(); // fill buffer
;
	jsr     _DoBuffer
;
; DoBuffer2(); // draw to ppu
;
	jsr     _DoBuffer2
;
; Horiz_scroll_Plus += 0x10;
;
	lda     #$10
	clc
	adc     _Horiz_scroll_Plus
	sta     _Horiz_scroll_Plus
;
; DoBuffer3(); // draw to ppu
;
	jsr     _DoBuffer3
;
; Horiz_scroll_Plus += 0x10;
;
	lda     #$10
	clc
	adc     _Horiz_scroll_Plus
	sta     _Horiz_scroll_Plus
;
; for (A = 0; A < 8; ++A)
;
	inc     _A
	jmp     L087D
;
; }
;
L079B:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ SetSpriteZero (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_SetSpriteZero: near

.segment	"CODE"

;
; SPRITE_ZERO[0] = 0x16; // y
;
	lda     #$16
	sta     _SPRITE_ZERO
;
; SPRITE_ZERO[1] = 0x30; // tile
;
	lda     #$30
	sta     _SPRITE_ZERO+1
;
; SPRITE_ZERO[2] = 0;  // attributes
;
	lda     #$00
	sta     _SPRITE_ZERO+2
;
; SPRITE_ZERO[3] = 0xd0; // x
;
	lda     #$D0
	sta     _SPRITE_ZERO+3
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ LoadHud (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_LoadHud: near

.segment	"CODE"

;
; PPU_ADDRESS = 0x20;
;
	lda     #$20
	sta     $2006
;
; PPU_ADDRESS = 0x42;
;
	lda     #$42
	sta     $2006
;
; for (index = 0; index < sizeof(HUD); ++index)
;
	lda     #$00
	sta     _index
L087E:	lda     _index
	cmp     #$18
	bcs     L087F
;
; PPU_DATA = HUD[index];
;
	ldy     _index
	lda     _HUD,y
	sta     $2007
;
; for (index = 0; index < sizeof(HUD); ++index)
;
	inc     _index
	jmp     L087E
;
; PPU_DATA = 3;
;
L087F:	lda     #$03
	sta     $2007
;
; PPU_ADDRESS = 0x23;
;
	lda     #$23
	sta     $2006
;
; PPU_ADDRESS = 0xc0;
;
	lda     #$C0
	sta     $2006
;
; for (index = 0; index < 8; ++index)
;
	lda     #$00
	sta     _index
L0880:	lda     _index
	cmp     #$08
	bcs     L07D5
;
; PPU_DATA = 0xaa;
;
	lda     #$AA
	sta     $2007
;
; for (index = 0; index < 8; ++index)
;
	inc     _index
	jmp     L0880
;
; }
;
L07D5:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ ShouldWeBuffer (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ShouldWeBuffer: near

.segment	"CODE"

;
; if (direction == 0)
;
	lda     _direction
	bne     L07E8
;
; if ((Horiz_scroll_Plus & 0x1e) == 0x02)
;
	lda     _Horiz_scroll_Plus
	and     #$1E
	cmp     #$02
	bne     L0881
;
; BufferTiles();
;
	jsr     _BufferTiles
;
; ++PPU_flag;
;
	inc     _PPU_flag
;
; if ((Horiz_scroll_Plus & 0x1e) == 0x10)
;
L0881:	lda     _Horiz_scroll_Plus
	and     #$1E
	cmp     #$10
	bne     L07E8
;
; BufferTiles2();
;
	jsr     _BufferTiles2
;
; ++PPU_flag2;
;
	inc     _PPU_flag2
;
; }
;
L07E8:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ NewRoom (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_NewRoom: near

.segment	"CODE"

;
; RoomB = RoomPlus + 1;
;
	lda     _RoomPlus
	clc
	adc     #$01
	sta     _RoomB
;
; RoomB &= 3; // keep it 0-3, we only have 4 rooms
;
	and     #$03
	sta     _RoomB
;
; Room_Address = ROOMS[RoomB]; // get the address of the room data
;
	ldx     #$00
	lda     _RoomB
	asl     a
	bcc     L0887
	inx
	clc
L0887:	adc     #<(_ROOMS)
	sta     ptr1
	txa
	adc     #>(_ROOMS)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	sta     _Room_Address+1
	dey
	lda     (ptr1),y
	sta     _Room_Address
;
; A = Horiz_scroll_Plus >> 4;
;
	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     _A
;
; if (Nametable_Plus == 0)
;
	lda     _Nametable_Plus
	bne     L0889
;
; for (index = 0; index < 15; ++index)
;
	sta     _index
	tax
L0888:	lda     _index
	cmp     #$0F
	bcs     L088B
;
; C_MAP2[A] = Room_Address[A];
;
	lda     #<(_C_MAP2)
	ldx     #>(_C_MAP2)
	clc
	adc     _A
	bcc     L0805
	inx
L0805:	jsr     pushax
	lda     _Room_Address
	ldx     _Room_Address+1
	ldy     _A
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; A += 0x10;
;
	lda     #$10
	clc
	adc     _A
	sta     _A
;
; for (index = 0; index < 15; ++index)
;
	ldx     #$00
	inc     _index
	jmp     L0888
;
; for (index = 0; index < 15; ++index)
;
L0889:	tya
	sta     _index
	tax
L088A:	lda     _index
	cmp     #$0F
	bcs     L088B
;
; C_MAP[A] = Room_Address[A];
;
	lda     #<(_C_MAP)
	ldx     #>(_C_MAP)
	clc
	adc     _A
	bcc     L0815
	inx
L0815:	jsr     pushax
	lda     _Room_Address
	ldx     _Room_Address+1
	ldy     _A
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; A += 0x10;
;
	lda     #$10
	clc
	adc     _A
	sta     _A
;
; for (index = 0; index < 15; ++index)
;
	ldx     #$00
	inc     _index
	jmp     L088A
;
; A = (Horiz_scroll_Plus + 0x10) >> 4;
;
L088B:	lda     _Horiz_scroll_Plus
	clc
	adc     #$10
	bcc     L081D
	inx
L081D:	jsr     shrax4
	sta     _A
;
; if (Nametable_Plus == 0)
;
	lda     _Nametable_Plus
	bne     L088D
;
; for (index = 0; index < 15; ++index)
;
	sta     _index
L088C:	lda     _index
	cmp     #$0F
	bcs     L0831
;
; C_MAP2[A] = Room_Address[A];
;
	lda     #<(_C_MAP2)
	ldx     #>(_C_MAP2)
	clc
	adc     _A
	bcc     L082A
	inx
L082A:	jsr     pushax
	lda     _Room_Address
	ldx     _Room_Address+1
	ldy     _A
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; A += 0x10;
;
	lda     #$10
	clc
	adc     _A
	sta     _A
;
; for (index = 0; index < 15; ++index)
;
	inc     _index
	jmp     L088C
;
; for (index = 0; index < 15; ++index)
;
L088D:	lda     #$00
	sta     _index
L088E:	lda     _index
	cmp     #$0F
	bcs     L0831
;
; C_MAP[A] = Room_Address[A];
;
	lda     #<(_C_MAP)
	ldx     #>(_C_MAP)
	clc
	adc     _A
	bcc     L083A
	inx
L083A:	jsr     pushax
	lda     _Room_Address
	ldx     _Room_Address+1
	ldy     _A
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	ldy     #$00
	jsr     staspidx
;
; A += 0x10;
;
	lda     #$10
	clc
	adc     _A
	sta     _A
;
; for (index = 0; index < 15; ++index)
;
	inc     _index
	jmp     L088E
;
; }
;
L0831:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ BufferTiles (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_BufferTiles: near

.segment	"CODE"

;
; index = 2;  // will be skipping the top 2 metatiles, it's the HUD
;
	lda     #$02
	sta     _index
;
; index2 = 0;
;
	lda     #$00
	sta     _index2
;
; index3 = 0;
;
	tax
	sta     _index3
;
; while (index < 15)
;
	jmp     L0894
;
; if (Nametable_Plus == 0)
;
L0891:	lda     _Nametable_Plus
	bne     L0892
;
; temp = C_MAP2[(Horiz_scroll_Plus >> 4) + (index << 4)]; // get the metatile
;
	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP2)
	sta     ptr1+1
	ldy     #<(_C_MAP2)
;
; else
;
	jmp     L0895
;
; temp = C_MAP[(Horiz_scroll_Plus >> 4) + (index << 4)]; // get the metatile
;
L0892:	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP)
	sta     ptr1+1
	ldy     #<(_C_MAP)
L0895:	lda     (ptr1),y
	sta     _temp
;
; temp3 = MT_color[temp]; // get color, store temp
;
	ldy     _temp
	lda     _MT_color,y
	sta     _temp3
;
; temp <<= 2; // x 4
;
	lda     _temp
	asl     a
	asl     a
	sta     _temp
;
; BUFFER1[index2] = METATILES[temp]; // get the tl tile
;
	lda     #<(_BUFFER1)
	ldx     #>(_BUFFER1)
	clc
	adc     _index2
	bcc     L0491
	inx
L0491:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER2[index2] = METATILES[temp]; // get the tr tile
;
	lda     #<(_BUFFER2)
	ldx     #>(_BUFFER2)
	clc
	adc     _index2
	bcc     L0498
	inx
L0498:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; BUFFER1[index2] = METATILES[temp]; // get the bl tile
;
	lda     #<(_BUFFER1)
	ldx     #>(_BUFFER1)
	clc
	adc     _index2
	bcc     L04A0
	inx
L04A0:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER2[index2] = METATILES[temp]; // get the br tile
;
	lda     #<(_BUFFER2)
	ldx     #>(_BUFFER2)
	clc
	adc     _index2
	bcc     L04A7
	inx
L04A7:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; ++index; // next round, difference is attribute table stuff
;
	inc     _index
;
; if (Nametable_Plus == 0)
;
	ldx     #$00
	lda     _Nametable_Plus
	bne     L0893
;
; temp = C_MAP2[(Horiz_scroll_Plus >> 4) + (index << 4)]; // get the metatile
;
	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP2)
	sta     ptr1+1
	ldy     #<(_C_MAP2)
;
; else
;
	jmp     L0896
;
; temp = C_MAP[(Horiz_scroll_Plus >> 4) + (index << 4)]; // get the metatile
;
L0893:	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP)
	sta     ptr1+1
	ldy     #<(_C_MAP)
L0896:	lda     (ptr1),y
	sta     _temp
;
; temp3 += (MT_color[temp] << 4); // get color, store temp
;
	ldy     _temp
	lda     _MT_color,y
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     _temp3
	sta     _temp3
;
; BUFFER5[index3] = temp3;
;
	ldy     _index3
	lda     _temp3
	sta     _BUFFER5,y
;
; temp <<= 2; // x 4
;
	lda     _temp
	asl     a
	asl     a
	sta     _temp
;
; BUFFER1[index2] = METATILES[temp]; // get the tl tile
;
	lda     #<(_BUFFER1)
	ldx     #>(_BUFFER1)
	clc
	adc     _index2
	bcc     L04C8
	inx
L04C8:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER2[index2] = METATILES[temp]; // get the tr tile
;
	lda     #<(_BUFFER2)
	ldx     #>(_BUFFER2)
	clc
	adc     _index2
	bcc     L04CF
	inx
L04CF:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; BUFFER1[index2] = METATILES[temp]; // get the bl tile
;
	lda     #<(_BUFFER1)
	ldx     #>(_BUFFER1)
	clc
	adc     _index2
	bcc     L04D7
	inx
L04D7:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER2[index2] = METATILES[temp]; // get the br tile
;
	lda     #<(_BUFFER2)
	ldx     #>(_BUFFER2)
	clc
	adc     _index2
	bcc     L04DE
	inx
L04DE:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index2;
;
	inc     _index2
;
; ++index3;
;
	inc     _index3
;
; ++index;
;
	inc     _index
;
; while (index < 15)
;
	ldx     #$00
L0894:	lda     _index
	cmp     #$0F
	jcc     L0891
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ BufferTiles2 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_BufferTiles2: near

.segment	"CODE"

;
; index = 2; // will be skipping the top 2 metatiles, later
;
	lda     #$02
	sta     _index
;
; index2 = 0;
;
	lda     #$00
	sta     _index2
;
; index3 = 0;
;
	tax
	sta     _index3
;
; while (index < 15)
;
	jmp     L089D
;
; if (Nametable_Plus == 0)
;
L089A:	lda     _Nametable_Plus
	bne     L089B
;
; temp = C_MAP2[(Horiz_scroll_Plus >> 4) + (index << 4)]; // get the mt
;
	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP2)
	sta     ptr1+1
	ldy     #<(_C_MAP2)
;
; else
;
	jmp     L089F
;
; temp = C_MAP[(Horiz_scroll_Plus >> 4) + (index << 4)]; // get the mt
;
L089B:	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP)
	sta     ptr1+1
	ldy     #<(_C_MAP)
L089F:	lda     (ptr1),y
	sta     _temp
;
; temp3 = MT_color[temp]; // get palette #, store temp3
;
	ldy     _temp
	lda     _MT_color,y
	sta     _temp3
;
; temp <<= 2; // x 4
;
	lda     _temp
	asl     a
	asl     a
	sta     _temp
;
; BUFFER3[index2] = METATILES[temp]; // get the tl tile
;
	lda     #<(_BUFFER3)
	ldx     #>(_BUFFER3)
	clc
	adc     _index2
	bcc     L0505
	inx
L0505:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER4[index2] = METATILES[temp]; // get the tr tile
;
	lda     #<(_BUFFER4)
	ldx     #>(_BUFFER4)
	clc
	adc     _index2
	bcc     L050C
	inx
L050C:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; BUFFER3[index2] = METATILES[temp]; // get the bl tile
;
	lda     #<(_BUFFER3)
	ldx     #>(_BUFFER3)
	clc
	adc     _index2
	bcc     L0514
	inx
L0514:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER4[index2] = METATILES[temp]; // get the br tile
;
	lda     #<(_BUFFER4)
	ldx     #>(_BUFFER4)
	clc
	adc     _index2
	bcc     L051B
	inx
L051B:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; ++index; // next round, difference is attribute table stuff
;
	inc     _index
;
; if (Nametable_Plus == 0)
;
	ldx     #$00
	lda     _Nametable_Plus
	bne     L089C
;
; temp = C_MAP2[(Horiz_scroll_Plus >> 4) + (index << 4)]; // get the mt
;
	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP2)
	sta     ptr1+1
	ldy     #<(_C_MAP2)
;
; else
;
	jmp     L08A0
;
; temp = C_MAP[(Horiz_scroll_Plus >> 4) + (index << 4)]; // get the mt
;
L089C:	lda     _Horiz_scroll_Plus
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	sta     ptr1
	stx     ptr1+1
	lda     _index
	jsr     aslax4
	clc
	adc     ptr1
	sta     ptr1
	txa
	adc     ptr1+1
	clc
	adc     #>(_C_MAP)
	sta     ptr1+1
	ldy     #<(_C_MAP)
L08A0:	lda     (ptr1),y
	sta     _temp
;
; temp3 += (MT_color[temp] << 4); // get palette #, store temp3
;
	ldy     _temp
	lda     _MT_color,y
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     _temp3
	sta     _temp3
;
; BUFFER6[index3] = temp3 << 2;
;
	lda     #<(_BUFFER6)
	ldx     #>(_BUFFER6)
	clc
	adc     _index3
	bcc     L0536
	inx
L0536:	sta     ptr1
	stx     ptr1+1
	lda     _temp3
	asl     a
	asl     a
	ldy     #$00
	sta     (ptr1),y
;
; temp <<= 2; // x 4
;
	lda     _temp
	asl     a
	asl     a
	sta     _temp
;
; BUFFER3[index2] = METATILES[temp]; // get the tl tile
;
	lda     #<(_BUFFER3)
	ldx     #>(_BUFFER3)
	clc
	adc     _index2
	bcc     L053C
	inx
L053C:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER4[index2] = METATILES[temp]; // get the tr tile
;
	lda     #<(_BUFFER4)
	ldx     #>(_BUFFER4)
	clc
	adc     _index2
	bcc     L0543
	inx
L0543:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; ++index2;
;
	inc     _index2
;
; BUFFER3[index2] = METATILES[temp]; // get the bl tile
;
	lda     #<(_BUFFER3)
	ldx     #>(_BUFFER3)
	clc
	adc     _index2
	bcc     L054B
	inx
L054B:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++temp;
;
	inc     _temp
;
; BUFFER4[index2] = METATILES[temp]; // get the br tile
;
	lda     #<(_BUFFER4)
	ldx     #>(_BUFFER4)
	clc
	adc     _index2
	bcc     L0552
	inx
L0552:	sta     ptr1
	stx     ptr1+1
	ldy     _temp
	lda     _METATILES,y
	ldy     #$00
	sta     (ptr1),y
;
; ++index2;
;
	inc     _index2
;
; ++index3;
;
	inc     _index3
;
; ++index;
;
	inc     _index
;
; while (index < 15)
;
	ldx     #$00
L089D:	lda     _index
	cmp     #$0F
	jcc     L089A
;
; for (index = 0; index < 8; ++index)
;
	stx     _index
L089E:	lda     _index
	cmp     #$08
	bcs     L055A
;
; BUFFER7[index] = BUFFER5[index] + BUFFER6[index];
;
	lda     #<(_BUFFER7)
	ldx     #>(_BUFFER7)
	clc
	adc     _index
	bcc     L0563
	inx
L0563:	sta     sreg
	stx     sreg+1
	ldy     _index
	lda     _BUFFER5,y
	sta     ptr1
	ldy     _index
	lda     _BUFFER6,y
	clc
	adc     ptr1
	ldy     #$00
	sta     (sreg),y
;
; for (index = 0; index < 8; ++index)
;
	inc     _index
	jmp     L089E
;
; }
;
L055A:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; AllOff(); // turn off screen
;
	jsr     _AllOff
;
; DrawBackground();
;
	jsr     _DrawBackground
;
; X1 = 0x80; // starting position
;
	lda     #$80
	sta     _X1
;
; Y1 = 0x70; // middle of screen
;
	lda     #$70
	sta     _Y1
;
; SetSpriteZero();
;
	jsr     _SetSpriteZero
;
; PPU_CTRL = 0x90; // rightward increments to PPU
;
	lda     #$90
	sta     $2000
;
; LoadPalette();
;
	jsr     _LoadPalette
;
; LoadHud();
;
	jsr     _LoadHud
;
; ResetScroll();
;
	jsr     _ResetScroll
;
; Wait_Vblank();
;
	jsr     _Wait_Vblank
;
; AllOn(); // turn on screen
;
	jsr     _AllOn
;
; while (NMI_flag == 0); // wait till NMI
;
L08A1:	lda     _NMI_flag
	beq     L08A1
;
; if (PPU_flag != 0)
;
	lda     _PPU_flag
	beq     L08A2
;
; DoBuffer2();
;
	jsr     _DoBuffer2
;
; PPU_CTRL = 0x94;
;
L08A2:	lda     #$94
	sta     $2000
;
; SCROLL = 0;
;
	lda     #$00
	sta     $2005
;
; SCROLL = 0;  // resetting scroll position, again
;
	sta     $2005
;
; if (PPU_flag2 != 0)
;
	lda     _PPU_flag2
	beq     L08A3
;
; DoBuffer3();
;
	jsr     _DoBuffer3
;
; PPU_CTRL = 0x94;
;
L08A3:	lda     #$94
	sta     $2000
;
; SCROLL = 0;
;
	lda     #$00
	sta     $2005
;
; SCROLL = 0;  // resetting scroll position, again
;
	sta     $2005
;
; Get_Input();
;
	jsr     _Get_Input
;
; PPU_flag = 0;
;
	lda     #$00
	sta     _PPU_flag
;
; PPU_flag2 = 0;
;
	sta     _PPU_flag2
;
; if ((joypad1 & START) != 0)
;
	lda     _joypad1
	and     #$10
	beq     L059E
;
; SPRITE_ZERO[1] = 0xff; // switch tiles to a very small one
;
	lda     #$FF
	sta     _SPRITE_ZERO+1
;
; SPRITE_ZERO[2] = 0x20; // attributes = behind the bg
;
	lda     #$20
	sta     _SPRITE_ZERO+2
;
; Sprite_Zero();
;
L059E:	jsr     _Sprite_Zero
;
; SCROLL = Horiz_scroll;
;
	lda     _Horiz_scroll
	sta     $2005
;
; SCROLL = 0;  // setting the new scroll position
;
	lda     #$00
	sta     $2005
;
; PPU_CTRL = (0x94 + Nametable);
;
	lda     _Nametable
	clc
	adc     #$94
	sta     $2000
;
; MoveLogic();
;
	jsr     _MoveLogic
;
; UpdateSprites();
;
	jsr     _UpdateSprites
;
; RoomPlus = Room;   // make a copy of variables, but 20 pixels right
;
	lda     _Room
	sta     _RoomPlus
;
; Nametable_Plus = Nametable;
;
	lda     _Nametable
	sta     _Nametable_Plus
;
; Horiz_scroll_Plus = Horiz_scroll + 0x20;
;
	lda     _Horiz_scroll
	clc
	adc     #$20
	sta     _Horiz_scroll_Plus
;
; if (Horiz_scroll_Plus < 0x20)
;
	cmp     #$20
	bcs     L08A4
;
; ++RoomPlus;
;
	inc     _RoomPlus
;
; ++Nametable_Plus;
;
	inc     _Nametable_Plus
;
; RoomPlus &= 3;
;
	lda     _RoomPlus
	and     #$03
	sta     _RoomPlus
;
; Nametable_Plus &= 1;
;
	lda     _Nametable_Plus
	and     #$01
	sta     _Nametable_Plus
;
; if ((Horiz_scroll_Plus & 0x1e) == 0)
;
L08A4:	lda     _Horiz_scroll_Plus
	and     #$1E
	bne     L05C5
;
; NewRoom(); // 6245 cycles
;
	jsr     _NewRoom
;
; ShouldWeBuffer(); // 4422 cycles
;
L05C5:	jsr     _ShouldWeBuffer
;
; NMI_flag = 0;
;
	lda     #$00
	sta     _NMI_flag
;
; while (1)
;
	jmp     L08A1

.endproc

